// DO-NOT-REMOVE begin-copyright-block 
//                                     
// Redistributions of any form whatsoever must retain and/or include the     
// following acknowledgment, notices and disclaimer:                         
//                                                                           
// This product includes software developed by Carnegie Mellon University.   
//                                                                           
// Copyright 2006 - 2008 by Eric Chung, Michael Ferdman, Brian Gold, Nikos   
// Hardavellas, Jangwoo Kim, Ippokratis Pandis, Minglong Shao, Jared Smolens,
// Stephen Somogyi, Evangelos Vlachos, Tom Wenisch, Anastassia Ailamaki,     
// Babak Falsafi and James C. Hoe for the SimFlex Project, Computer          
// Architecture Lab at Carnegie Mellon, Carnegie Mellon University.          
//                                                                           
// For more information, see the SimFlex project website at:                 
//   http://www.ece.cmu.edu/~simflex                                         
//                                                                           
// You may not use the name 'Carnegie Mellon University' or derivations      
// thereof to endorse or promote products derived from this software.        
//                                                                           
// If you modify the software you must place a notice on or within any       
// modified version provided or made available to any third party stating    
// that you have modified the software.  The notice shall include at least   
// your name, address, phone number, email address and the date and purpose  
// of the modification.                                                      
//                                                                           
// THE SOFTWARE IS PROVIDED 'AS-IS' WITHOUT ANY WARRANTY OF ANY KIND, EITHER 
// EXPRESS, IMPLIED OR STATUTORY, INCLUDING BUT NOT LIMITED TO ANY WARRANTY  
// THAT THE SOFTWARE WILL CONFORM TO SPECIFICATIONS OR BE ERROR-FREE AND ANY 
// IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE,  
// TITLE, OR NON-INFRINGEMENT.  IN NO EVENT SHALL CARNEGIE MELLON UNIVERSITY 
// BE LIABLE FOR ANY DAMAGES, INCLUDING BUT NOT LIMITED TO DIRECT, INDIRECT, 
// SPECIAL OR CONSEQUENTIAL DAMAGES, ARISING OUT OF, RESULTING FROM, OR IN   
// ANY WAY CONNECTED WITH THIS SOFTWARE (WHETHER OR NOT BASED UPON WARRANTY, 
// CONTRACT, TORT OR OTHERWISE).                                             
//                                     
// DO-NOT-REMOVE end-copyright-block   

#include <components/CacheTraceMemory/CacheTraceMemory.hpp>

  #define DBG_DefineCategories CacheTrace, Memory
  #define DBG_SetDefaultOps AddCat(CacheTrace) AddCat(Memory)
  #include DBG_Control()


#include <fstream>
#include <zlib.h>
#include <list>

#include <components/Common/Slices/TransactionTracker.hpp>
#include <components/Common/Slices/ExecuteState.hpp>
#include <components/Common/MemoryMap.hpp>

#include <core/simics/configuration_api.hpp>

#include <core/stats.hpp>
#include <core/performance/profile.hpp>

#define FLEXUS_BEGIN_COMPONENT CacheTraceMemory
#include FLEXUS_BEGIN_COMPONENT_IMPLEMENTATION()


namespace nCacheTraceMemory {

using namespace Flexus;
using namespace Flexus::Core;
using namespace Flexus::SharedTypes;
namespace Stat = Flexus::Stat;

using boost::intrusive_ptr;


/*
class CacheTraceMemorySimicsIface {
public:
  virtual void flushFiles() {
    DBG_Assert(false);
  }
};

class CacheTraceMemory_SimicsObject_Impl  {
    CacheTraceMemorySimicsIface * theComponentInterface; //Non-owning pointer
  public:
    CacheTraceMemory_SimicsObject_Impl(Flexus::Simics::API::conf_object_t * ) : theComponentInterface(0) {}

    void setComponentInterface(CacheTraceMemorySimicsIface * aComponentInterface) {
      theComponentInterface = aComponentInterface;
    }

    void flushTraceFiles() {
      theComponentInterface->flushFiles();
    }

};

class CacheTraceMemory_SimicsObject : public Simics::AddInObject <CacheTraceMemory_SimicsObject_Impl> {
    typedef Simics::AddInObject<CacheTraceMemory_SimicsObject_Impl> base;
   public:
    static const Simics::Persistence  class_persistence = Simics::Session;
    //These constants are defined in Simics/simics.cpp
    static std::string className() { return "CacheTraceMemory"; }
    static std::string classDescription() { return "CacheTraceMemory object"; }

    CacheTraceMemory_SimicsObject() : base() { }
    CacheTraceMemory_SimicsObject(Simics::API::conf_object_t * aSimicsObject) : base(aSimicsObject) {}
    CacheTraceMemory_SimicsObject(CacheTraceMemory_SimicsObject_Impl * anImpl) : base(anImpl) {}

    template <class Class>
    static void defineClass(Class & aClass) {

      aClass.addCommand
        ( & CacheTraceMemory_SimicsObject_Impl::flushTraceFiles
        , "flush-trace-files"
        , "flush the current trace files and switch to next"
        );

    }

};

Simics::Factory<CacheTraceMemory_SimicsObject> theCacheTraceMemoryFactory;
*/


typedef FILE   * FILE_p;
typedef FILE_p * FILE_pp;

typedef Flexus::SharedTypes::PhysicalMemoryAddress MemoryAddress;
typedef unsigned long long Time;

enum BlockStateEnum {
  StateShared,
  StateExclusive
};
struct BlockState : boost::counted_base {
  BlockState(int node)
    : state(StateShared)
    , producer(-1)
    , time(0)
    , sharers(1<<node)
    , pc(0)
  {}
  BlockState(int node, Time t, MemoryAddress aPc, bool aPriv)
    : state(StateExclusive)
    , producer(node)
    , time(t)
    , sharers(0)
    , pc(aPc)
    , priv(false)
  {}

  bool isSharer(int node) {
    return( sharers & (1<<node) );
  }
  void setSharer(int node) {
    sharers |= (1<<node);
  }
  void newShareList(int node, int oldOwner) {
    sharers = (1<<node);
    sharers |= (1<<oldOwner);
  }

  BlockStateEnum state;
  int producer;
  Time time;
  unsigned int sharers;
  MemoryAddress pc;
  bool priv;
};
typedef intrusive_ptr<BlockState> BlockState_p;

class MemoryStateTable {
  typedef std::map<MemoryAddress,BlockState_p> StateMap;
  typedef StateMap::iterator Iterator;
  typedef std::pair<MemoryAddress,BlockState_p> BlockPair;
  typedef std::pair<Iterator,bool> InsertPair;

public:
  MemoryStateTable()
  {}

  BlockState_p find(MemoryAddress anAddr) {
    Iterator iter = theBlockStates.find(anAddr);
    if(iter != theBlockStates.end()) {
      return iter->second;
    }
    return BlockState_p(0);
  }

  void remove(MemoryAddress anAddr) {
    Iterator iter = theBlockStates.find(anAddr);
    if(iter != theBlockStates.end()) {
      theBlockStates.erase(iter);
    }
  }

  long long size() {
    return theBlockStates.size();
  }

  void addEntry(MemoryAddress anAddr, BlockState_p anEntry) {
    // try to insert a new entry - if successful, we're done;
    // otherwise abort
    BlockPair insert = std::make_pair(anAddr, anEntry);
    InsertPair result = theBlockStates.insert(insert);
    DBG_Assert(result.second);
  }

private:
  StateMap theBlockStates;

};  // end class MemoryStateTable


class FLEXUS_COMPONENT(CacheTraceMemory) {
  FLEXUS_COMPONENT_IMPL( CacheTraceMemory );

  //CacheTraceMemory_SimicsObject theCacheTraceMemoryObject;

  struct Xact {
    int theNode;
    MemoryAddress theAddr;
    MemoryAddress thePC;
    bool thePriv;
    unsigned long theOpcode;
    MemoryTransport theTransport;
    Xact(int aNode, MemoryAddress anAddr, MemoryAddress aPC, bool aPriv, unsigned long anOpcode, MemoryTransport aTrans)
      : theNode(aNode)
      , theAddr(anAddr)
      , thePC(aPC)
      , thePriv(aPriv)
      , theOpcode(anOpcode)
      , theTransport(aTrans)
    {}
  };

  std::list< Xact > theRequests;
  std::list< Xact > theSnoops;


  struct PendStruct {
    int node;
    int count;
    MemoryTransport transport;
    std::deque<Xact> waiting;
    PendStruct(int aNode, int aCount, MemoryTransport aTrans)
      : node(aNode)
      , count(aCount)
      , transport(aTrans)
    {}
  };

  std::map<MemoryAddress,PendStruct> thePending;
  typedef std::map<MemoryAddress,PendStruct>::iterator PendIter;


  // state for all active blocks
  MemoryStateTable myStateTable;

  // output files
  struct OutfileRecord {
    std::string theBaseName;
    int theNumProcs;
    gzFile * theFiles;
    int    * theFileNo;
    long   * theFileLengths;

    static const int K = 1024;
    static const int M = 1024 * K;
    static const int kMaxFileSize = 512 * M;

    OutfileRecord(char * aName)
      : theBaseName(aName)
      , theNumProcs(-1)
      , theFiles(0)
    {}
    ~OutfileRecord() {
      if(theFiles != 0) {
        int ii;
        for(ii = 0; ii < theNumProcs; ii++) {
          gzclose(theFiles[ii]);
        }
        delete [] theFiles;
      }
    }

    void init(int numProcs) {
      int ii;
      theNumProcs = numProcs;
      theFiles = new gzFile[theNumProcs];
      theFileNo = new int[theNumProcs];
      theFileLengths = new long[theNumProcs];
      for(ii = 0; ii < theNumProcs; ii++) {
        theFiles[ii] = gzopen( nextFile(ii).c_str(), "w" );
        theFileNo[ii] = 0;
        theFileLengths[ii] = 0;
      }
    }
    void flush() {
      int ii;
      for(ii = 0; ii < theNumProcs; ii++) {
        switchFile(ii);
      }
    }
    std::string nextFile(int aCpu) {
      return ( theBaseName + boost::lexical_cast<std::string>(aCpu) + ".sordtrace64." + boost::lexical_cast<std::string>(theFileNo[aCpu]++) + ".gz" );
    }
    void switchFile(int aCpu) {
      DBG_Assert(theFiles);
      gzclose(theFiles[aCpu]);
      std::string new_file = nextFile(aCpu);
      theFiles[aCpu] = gzopen( new_file.c_str(), "w" );
      theFileLengths[aCpu] = 0;
      DBG_(Dev, ( << "switched to new trace file: " << new_file ) );
    }
    void writeFile(unsigned char * aBuffer, int aLength, int aCpu) {
      DBG_Assert(theFiles);
      gzwrite(theFiles[aCpu], aBuffer, aLength);

      theFileLengths[aCpu] += aLength;
      if (theFileLengths[aCpu] > kMaxFileSize) {
        switchFile(aCpu);
      }
    }
  };
  OutfileRecord OffchipReads;
  OutfileRecord OffchipWrites;
  OutfileRecord OffchipUpgrades;
  OutfileRecord CohReads;
  OutfileRecord CohWrites;
  OutfileRecord CohUpgrades;

  // file I/O buffer
  unsigned char theBuffer[64];

  std::ofstream theMemoryOut;

  std::vector< boost::intrusive_ptr<MemoryMap> > theMemoryMaps;

  std::vector< std::deque<MemoryTransport> > outQueue;

  //Statistics

  Stat::StatCounter statReads;
  Stat::StatCounter statOSReads;
  Stat::StatCounter statWrites;
  Stat::StatCounter statOSWrites;
  Stat::StatCounter statUpgrades;
  Stat::StatCounter statOSUpgrades;
  Stat::StatCounter statProductions;
  Stat::StatCounter statOSProductions;
  Stat::StatCounter statConsumptions;
  Stat::StatCounter statOSConsumptions;
  Stat::StatCounter statColdReads;
  Stat::StatCounter statColdWrites;
  Stat::StatCounter statColdUpgrades;
  Stat::StatCounter statColdConsumptions;
  Stat::StatUniqueCounter<MemoryAddress> statUniqueAddresses;
  Stat::StatUniqueCounter<MemoryAddress> statUniqueOSAddresses;
  Stat::StatUniqueCounter<MemoryAddress> statUniqueUserAddresses;
  Stat::StatUniqueCounter<MemoryAddress> statUniqueSharedAddresses;
  Stat::StatUniqueCounter<MemoryAddress> statUniqueSharedOSAddresses;
  Stat::StatUniqueCounter<MemoryAddress> statUniqueSharedUserAddresses;
  //Stat::StatInstanceCounter<MemoryAddress> statSharedAddressInstances;

public:
  FLEXUS_COMPONENT_CONSTRUCTOR(CacheTraceMemory)
    : base( FLEXUS_PASS_CONSTRUCTOR_ARGS )

    , OffchipReads("offchip_read")
    , OffchipWrites("offchip_write")
    , OffchipUpgrades("offchip_upgrade")
    , CohReads("coh_read")
    , CohWrites("coh_write")
    , CohUpgrades("coh_upgrade")

    //Stat initialization
    , statReads(statName() + "-Reads")
    , statOSReads(statName() + "-Reads:OS")
    , statWrites( statName() + "-Writes")
    , statOSWrites(statName() + "-Writes:OS")
    , statUpgrades( statName() + "-Upgrades")
    , statOSUpgrades(statName() + "-Upgrades:OS")
    , statProductions(statName() + "-Productions")
    , statOSProductions(statName() + "-Productions:OS")
    , statConsumptions(statName() + "-Consumptions")
    , statOSConsumptions(statName() + "-Consumptions:OS")
    , statColdReads(statName() + "-Reads:cold")
    , statColdWrites(statName() + "-Writes:cold")
    , statColdUpgrades(statName() + "-Upgrades:cold")
    , statColdConsumptions(statName() + "Consumptions:cold")
    , statUniqueAddresses(statName() + "-UniqueAddresses")
    , statUniqueOSAddresses(statName() + "-UniqueAddresses:OS")
    , statUniqueUserAddresses(statName() + "-UniqueAddresses:User")
    , statUniqueSharedAddresses(statName() + "-UniqueAddresses:Shared")
    , statUniqueSharedOSAddresses(statName() + "-UniqueAddresses:Shared:OS")
    , statUniqueSharedUserAddresses(statName() + "-UniqueAddresses:Shared:User")
    //, statSharedAddressInstances(statName() + "-SharedAddressInstances")

  {
    //theCacheTraceMemoryObject = theCacheTraceMemoryFactory.create("cache-trace-mem");
    //theCacheTraceMemoryObject->setComponentInterface(this);
  }

  ~CacheTraceMemoryComponent() {
    // the OutfileRecords will close everything
  }

  bool isQuiesced() const {
    bool ok =  theRequests.empty() && theSnoops.empty();
    return ok;
  }

  // Initialization
  void initialize() {
      if (cfg.TraceEnabled) {
        OffchipReads.init(cfg.NumProcs);
        OffchipWrites.init(cfg.NumProcs);
        OffchipUpgrades.init(cfg.NumProcs);
        CohReads.init(cfg.NumProcs);
        CohWrites.init(cfg.NumProcs);
        CohUpgrades.init(cfg.NumProcs);
      }

      if (cfg.CurvesEnabled) {
        theMemoryOut.open("memory.out");
        Stat::getStatManager()->openLoggedPeriodicMeasurement("Memory over Time", 1000000, Stat::Accumulate, theMemoryOut ,statName() + "-(?!SharedAddressInstances).*");
      }

      for(int ii = 0; ii < cfg.NumProcs; ii++) {
        theMemoryMaps.push_back(MemoryMap::getMemoryMap(ii));
        outQueue.push_back(std::deque<MemoryTransport>());
      }
  }

  // Ports
  FLEXUS_PORT_ARRAY_ALWAYS_AVAILABLE(FromNode_Snoop);
  void push(interface::FromNode_Snoop const &, index_t anIndex, MemoryTransport & transport) {
    DBG_(Iface, Comp(*this) Addr(transport[MemoryMessageTag]->address())
                ( << "snoop from node " << anIndex << " received: " << *transport[MemoryMessageTag] ) );

    MemoryAddress blockAddr = blockAddress(transport[MemoryMessageTag]->address());
    //Allocate the page in the MemoryMap, if not already done
    theMemoryMaps[anIndex]->node(blockAddr);

    switch (transport[MemoryMessageTag]->type()) {
      case MemoryMessage::DowngradeAck:
      case MemoryMessage::DownUpdateAck:
      case MemoryMessage::InvalidateAck:
      case MemoryMessage::InvUpdateAck:
        theSnoops.push_back( Xact( static_cast<int>(anIndex), blockAddr, MemoryAddress(0), 0, 0, transport ) );
        break;
      case MemoryMessage::EvictDirty:
      case MemoryMessage::EvictWritable:
      case MemoryMessage::EvictClean:
        // do nothing
        break;
      default:
        DBG_Assert(false, Component(*this) (<< "Don't know how to handle snoop message: " << *transport[MemoryMessageTag]) );
        return;
    }
  }

  FLEXUS_PORT_ARRAY_ALWAYS_AVAILABLE(FromNode_Req);
  void push(interface::FromNode_Req const &, index_t anIndex, MemoryTransport & transport) {
    DBG_(Iface, Comp(*this) Addr(transport[MemoryMessageTag]->address())
                ( << "request from node " << anIndex << " received: " << *transport[MemoryMessageTag] ) );

    MemoryAddress blockAddr = blockAddress(transport[MemoryMessageTag]->address());
    //Allocate the page in the MemoryMap, if not already done
    theMemoryMaps[anIndex]->node(blockAddr);
    MemoryAddress pc(0);
    bool priv = false;
    unsigned long opcode = 0;
    if(transport[ExecuteStateTag]) {
      /* doesn't seem to work any more - twenisch will fix this
      SharedTypes::ExecuteState & ex( static_cast<SharedTypes::ExecuteState &>(*transport[ExecuteStateTag]) );
      pc = ex.instruction().physicalInstructionAddress();
      priv = ex.instruction().isPriv();
      opcode = ex.instruction().opcode();
      */
    }

    switch (transport[MemoryMessageTag]->type()) {
      case MemoryMessage::ReadReq:
      case MemoryMessage::WriteReq:
      case MemoryMessage::UpgradeReq:
        theRequests.push_back( Xact( static_cast<int>(anIndex), blockAddr, pc, priv, opcode, transport ) );
        break;
      default:
        DBG_Assert(false, Component(*this) (<< "Don't know how to handle req message: " << *transport[MemoryMessageTag]) );
        return;
    }
  }

  void drive( interface::MemoryDrive const & ) {
    DBG_( Verb, Comp(*this) ( << "MemoryDrive" ));
    doMemoryDrive();

    int ii;
    for(ii = 0; ii < cfg.NumProcs; ii++) {
      while(!outQueue[ii].empty()) {
        if( FLEXUS_CHANNEL_ARRAY( ToNode, ii).available() ) {
          DBG_(Iface, Comp(*this) Addr(outQueue[ii].front()[MemoryMessageTag]->address())
                      ( << "msg for node " << ii << ": " << *outQueue[ii].front()[MemoryMessageTag] ) );
          FLEXUS_CHANNEL_ARRAY( ToNode, ii) << outQueue[ii].front();
          outQueue[ii].pop_front();
        }
        else {
          break;
        }
      }
    }
  }

private:
  void doMemoryDrive() {
    while (! theSnoops.empty() ) {
      // this snoop ack must match a pending operation
      PendIter iter = thePending.find(theSnoops.front().theAddr);
      DBG_Assert(iter != thePending.end(), Comp(*this));

      if(theSnoops.front().theTransport[MemoryMessageTag]->type() == MemoryMessage::InvUpdateAck ||
         theSnoops.front().theTransport[MemoryMessageTag]->type() == MemoryMessage::DownUpdateAck ) {
        // change upgrade reqeusts to write requests
        if(iter->second.transport[MemoryMessageTag]->type() == MemoryMessage::UpgradeReq) {
          iter->second.transport[MemoryMessageTag]->type() = MemoryMessage::WriteReq;
        }
      }

      bool stillPending = true;

      // check if this is the last ack expected
      --(iter->second.count);
      if(iter->second.count == 0) {
        // send the reply and wake a subsequent operation
        reply(iter->second.node, iter->second.transport);
        stillPending = false;

        while(!iter->second.waiting.empty()) {
          Xact woken = iter->second.waiting.front();
          iter->second.waiting.pop_front();
          int pending = performOperation(woken);
          if(pending > 0) {
            iter->second.node = woken.theNode;
            iter->second.count = pending;
            iter->second.transport = woken.theTransport;
            stillPending = true;
            break;
          }
          reply(woken.theNode, woken.theTransport);
        }
      }

      // clean up if no longer pending
      if(!stillPending) {
        thePending.erase(iter);
      }

      theSnoops.pop_front();
    }

    while (! theRequests.empty() ) {
      // first check for a pending operation for this address
      PendIter iter = thePending.find(theRequests.front().theAddr);
      if(iter != thePending.end()) {
        // attach to the pending operation
        iter->second.waiting.push_back(theRequests.front());
      }
      else {
        // perform the memory operation
        int pending = performOperation(theRequests.front());
        if(pending == 0) {
          reply(theRequests.front().theNode, theRequests.front().theTransport);
        }
        else {
          PendStruct waiting(theRequests.front().theNode,
                             pending,
                             theRequests.front().theTransport);
          thePending.insert( std::make_pair(theRequests.front().theAddr,waiting) );
        }
      }

      theRequests.pop_front();
    }
  }  // doMemoryDrive()

  int performOperation(Xact req) {
    int pending = 0;
    switch(req.theTransport[MemoryMessageTag]->type()) {
      case MemoryMessage::WriteReq:
        pending = recvWrite( req.theNode,
                             req.theAddr,
                             req.thePC,
                             req.thePriv,
                             req.theOpcode );
        break;
      case MemoryMessage::UpgradeReq:
        pending = recvUpgrade( req.theNode,
                               req.theAddr,
                               req.thePC,
                               req.thePriv,
                               req.theOpcode );
        break;
      case MemoryMessage::ReadReq:
        pending = recvRead( req.theNode,
                            req.theAddr,
                            req.thePC,
                            req.thePriv,
                            req.theOpcode );
        break;
      default:
        DBG_Assert(false, Component(*this) (<< "Don't know how to handle message: " << *req.theTransport[MemoryMessageTag]) );
    }
    return pending;
  }

  void reply(int node, MemoryTransport transport) {
    intrusive_ptr<MemoryMessage> reply;
    switch (transport[MemoryMessageTag]->type()) {
      case MemoryMessage::ReadReq:
        reply = new MemoryMessage(MemoryMessage::MissReply, transport[MemoryMessageTag]->address());
        break;
      case MemoryMessage::WriteReq:
        reply = new MemoryMessage(MemoryMessage::MissReplyWritable, transport[MemoryMessageTag]->address());
        break;
      case MemoryMessage::UpgradeReq:
        reply = new MemoryMessage(MemoryMessage::UpgradeReply, transport[MemoryMessageTag]->address());
        break;
      default:
        DBG_Assert(false, Component(*this) (<< "Don't know how to handle req message.") );
    }

    reply->reqSize() = cfg.BlockSize;
    transport.set(MemoryMessageTag, reply);
    outQueue[node].push_back(transport);
  }

  int doDowngrade(MemoryAddress addr, int node) {
    DBG_Assert( (node>=0) && (node<cfg.NumProcs) );
    intrusive_ptr<MemoryMessage> snoop(new MemoryMessage(MemoryMessage::Downgrade, addr));
    MemoryTransport transport;
    transport.set(MemoryMessageTag, snoop);
    outQueue[node].push_back(transport);
    return 1;
  }

  int doInvalidate(MemoryAddress addr, int node) {
    DBG_Assert( (node>=0) && (node<cfg.NumProcs) );
    intrusive_ptr<MemoryMessage> snoop(new MemoryMessage(MemoryMessage::Invalidate, addr));
    MemoryTransport transport;
    transport.set(MemoryMessageTag, snoop);
    outQueue[node].push_back(transport);
    return 1;
  }

  int doInvalidate(MemoryAddress addr, unsigned int sharers, int node) {
    int count = 0;
    int ii;

    for(ii = 0; ii < cfg.NumProcs; ii++) {
      if(sharers & (1<<ii)) {
        // don't invalidate the upgrader
        if(ii != node) {
          count += doInvalidate(addr, ii);
        }
      }
    }
    return count;
  }


  //--- Base functions for maintaining state -----------------------------------
  int recvRead(int node, MemoryAddress addr, MemoryAddress pc, bool priv, unsigned long opcode) {
    DBG_(Verb, ( << "got read from node " << node << " for addr " << addr ) );
    int pending = 0;

    ++statReads;
    if (priv) ++statOSReads;

    if (cfg.TrackUniqueAddress) {
      statUniqueAddresses << addr;
      if (priv) {
        statUniqueOSAddresses << addr;
      } else {
        statUniqueUserAddresses << addr;
      }
    }

    // grab the current state of this block
    BlockState_p block = myStateTable.find(addr);
    if(block) {
      DBG_(Verb, ( << "retrieved block state" ) );

      if(block->state == StateShared) {
        DBG_(Verb, ( << "state shared" ) );

        if(!block->isSharer(node)) {
          DBG_(Verb, ( << "new sharer" ) );

          // new sharer - record first access to this block by this node
          //consumption(addr, pc, node, currentTime(), block->producer, block->time, priv);
          block->setSharer(node);
        }
      }
      else {  // StateExclusive
        // check if the reader is already the node with exclusive access
        if(block->producer == node) {
          DBG_(Verb, ( << "state exclusive - read by owner" ) );
        }
        else {
          DBG_(Verb, ( << "state exclusive - read by another" ) );

          pending = doDowngrade(addr, block->producer);

          // record the last store time of this address to file
          //production(block->producer, addr, block->pc, block->time, block->priv);

          // transition to shared and record this first read time
          block->state = StateShared;
          block->newShareList(node, block->producer);
          //consumption(addr, pc, node, currentTime(), block->producer, block->time, priv);
        }
      }
    }
    else {
      DBG_(Verb, ( << "no existing block state" ) );

      ++statColdReads;

      // no current state for this block
      block = new BlockState(node);
      myStateTable.addEntry(addr, block);

      // record this first read time
      //consumption(addr, pc, node, currentTime(), block->producer, block->time, priv);
    }

    DBG_(Verb, ( << "done read" ) );
    return pending;
  }

  int recvWrite(int node, MemoryAddress addr, MemoryAddress pc, bool priv, unsigned long opcode) {
    DBG_(Verb, ( << "got write from node " << node << " for addr " << addr ) );
    int pending = 0;

    ++statWrites;
    if (priv) ++statOSWrites;

    if (cfg.TrackUniqueAddress) {
      statUniqueAddresses << addr;
      if (priv) {
        statUniqueOSAddresses << addr;
      } else {
        statUniqueUserAddresses << addr;
      }
    }

    // grab the current state of this block
    BlockState_p block = myStateTable.find(addr);
    if(block) {
      DBG_(Verb, ( << "retrieved block state" ) );

      if(block->state == StateShared) {
        DBG_(Verb, ( << "state shared" ) );

        pending = doInvalidate(addr, block->sharers, node);

        // transition the block to exclusive
        block->state = StateExclusive;
        block->producer = node;
        block->time = currentTime();
        block->pc = pc;
        block->priv = priv;
      }
      else {  // StateExclusive
        DBG_(Verb, ( << "state exclusive" ) );

        if(node == block->producer) {
          DBG_(Verb, ( << "same producer" ) );

          // same node - just update production time
          block->time = currentTime();
          block->pc = pc;
          block->priv = priv;
        }
        else {
          DBG_(Verb, ( << "new producer" ) );

          pending = doInvalidate(addr, block->producer);

          // different node - record the last production for that node
          //production(block->producer, addr, block->pc, block->time, block->priv);

          // transition to new producer
          block->producer = node;
          block->time = currentTime();
          block->pc = pc;
          block->priv = priv;
        }
      }
    }
    else {
      DBG_(Verb, ( << "no existing block state" ) );

      ++statColdWrites;

      // no current state for this block
      block = new BlockState(node, currentTime(), pc, priv);
      myStateTable.addEntry(addr, block);
    }

    DBG_(Verb, ( << "done write" ) );
    return pending;
  }

  int recvUpgrade(int node, MemoryAddress addr, MemoryAddress pc, bool priv, unsigned long opcode) {
    DBG_(Verb, ( << "got upgrade from node " << node << " for addr " << addr ) );
    int pending = 0;

    ++statUpgrades;
    if (priv) ++statOSUpgrades;

    if (cfg.TrackUniqueAddress) {
      statUniqueAddresses << addr;
      if (priv) {
        statUniqueOSAddresses << addr;
      } else {
        statUniqueUserAddresses << addr;
      }
    }

    // grab the current state of this block
    BlockState_p block = myStateTable.find(addr);
    if(block) {
      DBG_(Verb, ( << "retrieved block state" ) );

      if(block->state == StateShared) {
        DBG_(Verb, ( << "state shared" ) );

        pending = doInvalidate(addr, block->sharers, node);

        // transition the block to exclusive
        block->state = StateExclusive;
        block->producer = node;
        block->time = currentTime();
        block->pc = pc;
        block->priv = priv;
      }
      else {  // StateExclusive
        DBG_(Verb, ( << "state exclusive" ) );

        if(node == block->producer) {
          DBG_(Verb, ( << "same producer" ) );

          // same node - just update production time
          block->time = currentTime();
          block->pc = pc;
          block->priv = priv;
        }
        else {
          DBG_(Verb, ( << "new producer" ) );

          pending = doInvalidate(addr, block->producer);

          // different node - record the last production for that node
          //production(block->producer, addr, block->pc, block->time, block->priv);

          // transition to new producer
          block->producer = node;
          block->time = currentTime();
          block->pc = pc;
          block->priv = priv;
        }
      }
    }
    else {
      DBG_(Verb, ( << "no existing block state" ) );

      ++statColdUpgrades;

      // no current state for this block
      block = new BlockState(node, currentTime(), pc, priv);
      myStateTable.addEntry(addr, block);
    }

    DBG_(Verb, ( << "done upgrade" ) );
    return pending;
  }


  //--- Functions for trace generation -----------------------------------------
  void flushFiles() {
    if (cfg.TraceEnabled) {
      DBG_(Dev, Comp(*this) ( << "Switching all output files" ) );
      OffchipReads.flush();
      OffchipWrites.flush();
      OffchipUpgrades.flush();
      CohReads.flush();
      CohWrites.flush();
      CohUpgrades.flush();
    }
  }


  //--- Utility functions ------------------------------------------------------
  MemoryAddress blockAddress(MemoryAddress addr) {
    return MemoryAddress( addr & ~(cfg.BlockSize-1) );
  }

  Time currentTime() {
    return theFlexus->cycleCount();
  }

};

}//End namespace nCacheTraceMemory

FLEXUS_COMPONENT_INSTANTIATOR( CacheTraceMemory, nCacheTraceMemory );
FLEXUS_PORT_ARRAY_WIDTH( CacheTraceMemory, ToNode ) { return Flexus::Core::ComponentManager::getComponentManager().systemWidth(); }
FLEXUS_PORT_ARRAY_WIDTH( CacheTraceMemory, FromNode_Snoop ) { return Flexus::Core::ComponentManager::getComponentManager().systemWidth(); }
FLEXUS_PORT_ARRAY_WIDTH( CacheTraceMemory, FromNode_Req ) { return Flexus::Core::ComponentManager::getComponentManager().systemWidth(); }

#include FLEXUS_END_COMPONENT_IMPLEMENTATION()
#define FLEXUS_END_COMPONENT CacheTraceMemory

  #define DBG_Reset
  #include DBG_Control()
